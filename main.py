#!/usr/bin/env python3# -*- coding=utf8 -*-"""# Author: WenT_Ethan# Text Editor: Vim# Created Time : Thu Apr 29 12:45:23 2021# File Name: main# Description:"""import osimport cv2import platformimport numpy as np# print(os.name)if (platform.system() == 'Windows'):    User_name = os.environ.get('USERNAME')    path = "C:/Users/" + User_name + "/Downloads/"    FILE = "Learn_OpenCV"    if not os.path.isfile(path+FILE):        os.mkdir(path+FILE)    save_path = pathelse:    User_name = os.environ.get('USER')    path = "~/Downloads/github/"    FOLDER = "Learn_OpenCV"    if not os.path.isfile(path+FOLDER):        os.mkdir(path+FOLDER)    save_path = path+FOLDER# Access the Web_CamWeb_Cam = cv2.VideoCapture(0)  # We can change the value as input video# Rescale the camera capture windowWeb_Cam.set(3, 640)Web_Cam.set(4, 480)# Cap_width = Web_Cap.set(3, 640)# Cap_Height = Web_Cap.set(4, 480)# Image stacking functiondef stackImages(scale, imgArray):    rows = len(imgArray)    cols = len(imgArray[0])    rowsAvailable = isinstance(imgArray[0], list)    width = imgArray[0][0].shape[1]    height = imgArray[0][0].shape[0]    if rowsAvailable:        for x in range(0, rows):            for y in range(0, cols):                if imgArray[x][y].shape[:2] == imgArray[0][0].shape[:2]:                    imgArray[x][y] = cv2.resize(                        imgArray[x][y], (0, 0), None, scale, scale)                else:                    imgArray[x][y] = cv2.resize(imgArray[x][y],                                                (imgArray[0][0].shape[1],                                                 imgArray[0][0].shape[0]),                                                None, scale, scale)                if len(imgArray[x][y].shape) == 2:                    imgArray[x][y] = cv2.cvtColor(                        imgArray[x][y], cv2.COLOR_GRAY2BGR)        imageBlank = np.zeros((height, width, 3), np.uint8)        horizantal = [imageBlank]*rows        for x in range(0, rows):            horizantal[x] = np.hstack(imgArray[x])        ver = np.vstack(horizantal)    else:        for x in range(0, rows):            if imgArray[x].shape[:2] == imgArray[0].shape[:2]:                imgArray[x] = cv2.resize(                    imgArray[x], (0, 0), None, scale, scale)            else:                imgArray[x] = cv2.resize(imgArray[x], (imgArray[0].shape[1],                                                       imgArray[0].shape[0]),                                         None, scale, scale)            if len(imgArray[x].shape) == 2:                imgArray[x] = cv2.cvtColor(imgArray[x], cv2.COLOR_GRAY2BGR)        horizantal = np.hstack(imgArray)        ver = horizantal    return ver# TrackBarscv2.namedWindow("TrackBars")cv2.resizeWindow("TrackBars", 640, 240)def TrackBar_func(valu):    passdef createTrackbars_func():    h_min = cv2.createTrackbar("Hue min", "TrackBars", 0, 179, TrackBar_func)    h_max = cv2.createTrackbar("Hue Max", "TrackBars", 179, 179, TrackBar_func)    s_min = cv2.createTrackbar("Sat Min", "TrackBars", 0, 255, TrackBar_func)    s_max = cv2.createTrackbar("Sat Max", "TrackBars", 255, 255, TrackBar_func)    v_min = cv2.createTrackbar("Val Min", "TrackBars", 0, 255, TrackBar_func)    v_max = cv2.createTrackbar("val Max", "TrackBars", 255, 255, TrackBar_func)    return h_min, h_max, s_min, s_max, v_min, v_maxdef getTrackbars_func():    name = [        "Hue Min",        "Hue Max",        "Sat Min",        "Sat Max",        "Val Min",        "val Max"    ]    val = []    for HSV in name:        values = cv2.getTrackbarPos(HSV, "TrackBars")        val.append(values)    return np.array(val)createTrackbars_func()HueSaturationValue = getTrackbars_func()HSV_min = [HueSaturationValue[0], HueSaturationValue[2], HueSaturationValue[4]]HSV_max = [HueSaturationValue[1], HueSaturationValue[3], HueSaturationValue[5]]count = 0# Show the result and exit by press "q"while True:    # print(HueSaturationValue)  # print the HSV in real time    success, img = Web_Cam.read()    cv2.imshow("Video", img)    # Edge detector    imgCanny = cv2.Canny(img, 100, 100)    # Resize the image    imgResize = cv2.resize(img, (500, 800))  # (width, height)    # Crop the image    # [cut start point : end point, crop start point : end point]    imgCropped = img[0:100, 100:400]    # img masking#     mask = cv2.inRange(img, HSV_min, HSV_max)#     imgResult = cv2.bitwise_and(img, img, mask=mask)    if cv2.waitKey(1) & 0xFF == ord('s'):        cv2.imwrite(path + "DetectResult_" + str(count) + ".jpg", img_detect)        cv2.rectangle(img, (0, 200), (640, 300), (0, 255, 0), cv2.FILLED)        cv2.putText(img, "Wrap saved", (150, 265), cv2.FONT_HERSHEY_DUPLEX,                    2, (0, 0, 255), 2)        cv2.imshow("Result", img)        cv2.waitKey(500)        count += 1    if cv2.waitKey(1) & 0xFF == ord('q'):        break